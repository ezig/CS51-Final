\documentclass[12pt]{article}

\usepackage{customizations}

\hypersetup{
    colorlinks=true,       % false: boxed links; true: colored links
    urlcolor=blue           % color of external links
}

\begin{document}

\title{
  CS51 Project Draft Specification\\
  \Large{Solving Sliding Tile N-Puzzles With Genetic Algorithms and Other Search Heuristics}
}
\author{Eric Chan ericchan@college.harvard.edu \\ Liam Mulshine lmulshine@college.harvard.edu \\ Luca Schroeder schroeder@college.harvard.edu \\ Ezra Zigmond ezigmond@college.harvard.edu \\ }
\date{10 April 2015}
\maketitle
\section{Brief Overview}
In this project, we hope to gain an understanding of genetic algorithms by applying them so solve N-Puzzles. N-Puzzles (or “sliding tile puzzles”) are a popular way to compare and understand different search heuristics. Solving a planning problem like N-Puzzles using genetic algorithms presents an interesting challenge because each move significantly affects the valid moves at the next steps, and thus chromosomes in the algorithm must be interpreted in the context of the current state. We aim to implement a genetic algorithm for solving N-Puzzles and compare the results with implementations of against a more conventional approach to solving N-Puzzles using A* and search heuristics such as the Manhattan Distance and Pattern Database heuristics. The goal is to learn about genetic algorithms and search problems, and likely learn a new programming language along the way. 
						
\section{Feature List} 

\subsection{Core Features For Minimally Complete Project}
\begin{itemize}
	\item \textbf{Generate solvable N-puzzles} (half of all possible N-puzzles are impossible to solve — sufficient condition for solvability outlined in \underline{\href{http://cseweb.ucsd.edu/~ccalabro/essays/15_puzzle.pdf}{this}} paper)
\item \textbf{Implement the genetic approach to solving N-puzzles outlined in \underline{\href{http://cseweb.ucsd.edu/~ccalabro/essays/15_puzzle.pdf}{this}} paper.} This uses indirect encoding for genes, meaning we conveniently do not have to use a match fitness function in our fitness evaluation. 
\item \textbf{Implement the Manhattan distance/taxicab geometry heuristic using an A*/IDA* algorithm} Manhattan distance is explained \underline{\href{http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html}{here}}, and \underline{\href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.58.7&rep=rep1&type=pdf }{this paper}} discusses possible implementations, including DFS/BFS search, “best-first” search and “depth-first iterative deepening” which combines all three. 
\item \textbf{Create graphs comparing the effectiveness of the algorithms} so that we can easily present the results that we find.
\end{itemize}


\subsection{Cool Extension Ideas}

\begin{itemize}
\item \textbf{Some sort of visualization} — displaying a randomly generated N-puzzle and then displaying an animation of the solutions given by different algorithms along with a scoreboard of their times. Could even have the user try (unsuccessfully most likely) to beat the solutions generated by different heuristic techniques!
	
\item \textbf{Implementing the Linear Conflict Heuristic outlined \href{http://academiccommons.columbia.edu/download/fedora_content/download/ac:141290/CONTENT/cucs-219-85.pdf}{here}.}

\item \textbf{Incorporating a recursive planning heuristic} into the genetic algorithm as outlined in \underline{\href{http://www.engr.colostate.edu/~hj/journals/81.pdf}{this paper}} for dramatic improvements to performance and the success of the genetic algorithm in solving larger N-puzzles—i.e. for a 15-puzzle (4x4), solve the fourth column and fourth row (now reducing the problem to a 8-puzzle), then solve the remaining third column and third row tiles, etc. Implementing this recursive planning heuristic would also implement the Pattern Database heuristic introduced in \underline{\href{http://arxiv.org/pdf/1107.0050.pdf}{this paper}}. 
\end{itemize}									
\section{Technical Specification}
			
Right now, it made the most sense to us to take an object-oriented approach and therefore divide the different parts of the problem into classes. However, we realize that the genetic solver will need to keep around an immutable copy of the original puzzle, so it may ultimately be better to implement the algorithm functionally so that we don’t have to worry about the changing state of puzzles. Something else we’re still thinking about is whether it makes sense for a puzzle to compute its own fitness, so that we don’t have to give outside access to the internal tile state, or whether the solver should be able to look directly into the puzzle and take care of fitness evaluation. \\\\
Below, we provide pseudo-ML style signatures for our classes and methods with high level explanations of the way the functions work. \\
\lstinputlisting[language = ML]{spec.ml}
						
\section{Next Steps}
\begin{itemize}
	\item \textbf{Think more about which language we will use.} Right now, we are still deciding if taking an object-oriented or a more purely functional approach to the problem would make more sense. If we decide to go for a primarily object oriented approach, we might use a high level language like Ruby or Python. If we instead decide to aim for a mostly functional approach, we might want to try out a new functional language like Clojure or Scheme. However, another interesting language we have considered is Scala, which (like OCaml) has good support for both functional and object oriented paradigms and would allow us to try to use as much functional code as possible. Choosing a language will likely involve setting up several different environments and playing around to see what we like.
	\item \textbf{Clarify our understanding of the algorithm.} Although we mostly understand the genetic approach that we plan to implement, there are still . We will try to seek out additional resources to clarify our understanding, or perhaps try to go over parts of the paper with our advising TF to see if he might be able to clarify some of our questions.
	\item \textbf{Think about what graphing library we will use.} We already know that Python, through Matplotlib and NumPy has very good support for graphing, but when we decide on a language, we will investigate if there are good plotting libraries for that language. Otherwise, we could certainly output our results as test and feed them into a Python program to plot the results.
\end{itemize}
\end{document}